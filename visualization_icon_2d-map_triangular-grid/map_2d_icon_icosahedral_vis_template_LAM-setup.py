#!/usr/bin/env python
# coding: utf-8

'''
Visualisation template for plotting ICON data on its icosahedral grid on a map

Purpose:
Visualisation template and demonstrator for plotting ICON data on its 
icosahedral native grid on a map using matplotlib and cartopy. This is a 
template and demonstrator on how TSMP2 ICON (or eCLM) data on its native 
simulation grid can be plotted with a rotated map projection as a basis, 
including proper colorbar, etc. Data is plotted without distortion, 
either vectorized or rasterized, the map edges align with the data. The 
tool is currently configured to plot 3km or 12km horizontal resolution 
ICON data (R13B07, R13B05) over a EURO-CORDEX EUR-12 model domain. A
recommendation for various use cases is given at the end.

Inputs:
- ICON "main grid file"
- External parameter file
- Rotated pole longitude and latitude
All based on the Zonda ICON Grid and EXTPAR Interface. Using the "europe011" 
template.
'''

import time, sys

import xarray as xr
import numpy as np

import matplotlib.pyplot as plt
import matplotlib.tri as tri
import cartopy.crs as ccrs
import cartopy.feature as cfeature


__authors__ = "Klaus GOERGEN"
__orcid__ = "https://orcid.org/0000-0002-4208-3444"
__email__ = ""
__maintainer__ = "Klaus GOERGEN"
__copyright__ = "Copyright (c) 2025, https://www.fz-juelich.de (FZJ)"
__license__ = "MIT"
__version__ = "1.0.0"
__date__ = "2025-08-11"
__status__ = "Beta"
__credits__ = [
    "DKRZ",
    "Niklas WAGNER"
    ]
__acknowledgements__ = [
    "The authors acknowledge the use of the Zonda service (https://zonda.ethz.ch/) for the preparation of external parameter data for the ICON model. Zonda has been developed and is maintained by the Center for Climate Systems Modeling (C2SM), ETH Zurich, in cooperation with the Federal Office for Meteorology and Climatology MeteoSwiss and Deutscher Wetterdienst (DWD)."
    ]
__references__ = [
    "https://docs.dkrz.de/doc/visualization/sw/python/source_code/python-matplotlib-example-unstructured-icon-triangles-plot-python-3.html",
    "https://docs.dkrz.de/doc/visualization/sw/python/source_code/python-matplotlib-triangular-grid-with-tripcolor-ICON.html",
    "https://zonda.ethz.ch"
    ]


def main():

    t1 = time.time()

    # rotated pole: hardcoded (assume only basic files exist) or from file  
    lon_northpole = -162.0
    lat_northpole = 39.25
    # data generated by ZONDA
    dsPnFn = '../data_test_geo.EUR-12_R13B05_ICON_via-zonda_v20250731orig/europe011_DOM01_external_parameter.nc'
    gridPnFn = '../data_test_geo.EUR-12_R13B05_ICON_via-zonda_v20250731orig/europe011_DOM01.nc'
    #dsPnFn = '../data_test_geo.EUR-3_R13B07_ICON_via-zonda_v20250731orig/europe011_DOM01_external_parameter.nc'
    #gridPnFn = '../data_test_geo.EUR-3_R13B07_ICON_via-zonda_v20250731orig/europe011_DOM01.nc'
    
    ds = xr.open_dataset(dsPnFn)    
    dsGrid = xr.open_dataset(gridPnFn)
    #print(ds)
    #print(dsGrid)

    # triangle (=grid cells) center coords
    clon = np.rad2deg(dsGrid.clon.values)
    clat = np.rad2deg(dsGrid.clat.values)
    # triangle vertex coords
    vlon = np.rad2deg(dsGrid.vlon.values)
    vlat = np.rad2deg(dsGrid.vlat.values)

    # define a rectangular geographic mask
    # default is for full domain by using large limits
    # 40 50 4 9 for western Alps testing
    mask = (
    (clat > 0)
    & (clat < 90)
    & (clon > -180)
    & (clon < 180)
    )

    # corner indices for each triangular grid cell
    # counting needs to be reset from starting at 1 to 0, and transposed
    voc = dsGrid.vertex_of_cell.T[mask].values - 1

    # get the extend of the geolocated data (model domain) 
    used_vertices = np.unique(voc)

    # generate a rotated grid of the vertices coords
    # https://www.dwd.de/SharedDocs/downloads/DE/modelldokumentationen/nwv/cosmo_de/cosmo_de_dbbeschr_version_2_4_161124.pdf
    # np.radians(dsRotClGrid.rotated_pole.grid_north_pole_longitude)
    # np.radians(dsRotClGrid.rotated_pole.grid_north_pole_latitude)
    lon_northpole_rot = np.radians(lon_northpole)
    lat_northpole_rot = np.radians(lat_northpole)
    vlon_rot = np.degrees(np.arctan2(-np.cos(dsGrid.vlat.values)*
        np.sin(dsGrid.vlon.values - lon_northpole_rot), 
        -np.cos(dsGrid.vlat.values)*np.sin(lat_northpole_rot)*
        np.cos(dsGrid.vlon.values-lon_northpole_rot)+
        np.sin(dsGrid.vlat.values)*np.cos(lat_northpole_rot))) 
    vlon_rot[vlon_rot<-180] += 360
    vlon_rot[vlon_rot>180] -= 360
    vlat_rot = np.degrees(np.arcsin(np.sin(dsGrid.vlat.values)*
        np.sin(lat_northpole_rot)+np.cos(dsGrid.vlat.values)*
        np.cos(lat_northpole_rot)*np.cos(dsGrid.vlon.values - 
        lon_northpole_rot)))

    # map extend baed on rotated vertices' coords, no cutting of triangles
    vlat_rot_min = vlat_rot[used_vertices].min()
    vlat_rot_max = vlat_rot[used_vertices].max()
    vlon_rot_min = vlon_rot[used_vertices].min()
    vlon_rot_max = vlon_rot[used_vertices].max()

    # triangulation object from ICON, no Delaunay triangulation
    # very efficient, takes minimum time
    triang = tri.Triangulation(vlon, vlat, voc)
    #print(triang, triang.triangles.shape, triang.is_delaunay)

    # use data + map projection
    # from ICON "main grid file"
    # :grid_mapping_name = "lat_long_on_sphere" ;
    # :crs_id = "urn:ogc:def:cs:EPSG:6.0:6422" ;
    # :crs_name = "Spherical 2D Coordinate System"
    crs_data = ccrs.PlateCarree()
    crs_map = ccrs.RotatedPole(pole_longitude=-162, pole_latitude=39.25)

    # demo with 10inch
    # single column 3.5inch
    # double column 7.0inch
    # slides 5.75inch, e.g., @300dpi with png
    fig1 = plt.figure(figsize=(5.0, 5.0))

    ax1 = plt.subplot(111, projection=crs_map)
    ax1.set_aspect('equal')

    ax1.coastlines(resolution='50m',linewidth=0.5)
    # ax1.gridlines(dms=True, linewidth=1, color='gray', alpha=0.5, 
    #               linestyle='--',
    #               draw_labels={"bottom": "x", "left": "y"}, 
    #               x_inline=False, y_inline=False)
    # ax1.add_feature(cfeature.BORDERS, linestyle='-', alpha=.5, linewidth=0.5)
    ax1.add_feature(cfeature.OCEAN, color='azure')
    # ax1.add_feature(cfeature.LAKES, color='skyblue')

    ax1.set_title('ICON external parameters (EUR-12),\nplotting demo with icosahedral grid', 
        fontsize=9)

    # ax1.text(0.015, 0.88, "stats surf. w. change [mm]:\n"+
    #     "q05 = "+ str(da.quantile(0.05).values.round(1))+"\n"
    #     "q25 = "+ str(da.quantile(0.25).values.round(1))+"\n"
    #     "med = "+ str(da.median().values.round(1))+"\n"
    #     "mean = "+ str(da.mean().values.round(1))+"\n"
    #     "q75 = "+ str(da.quantile(0.75).values.round(1))+"\n"
    #     "q95 = "+ str(da.quantile(0.95).values.round(1))+"\n",
    #     transform=ax.transAxes, ha='left', va='top', fontsize=7)

    cmapDiscr = plt.get_cmap('terrain', 50)
    levelsVals = (np.arange(51)*50)

    # for an all-vectorized option just "rasterized=False", you need to test
    # if you have any hairline issues, rasterize the data triangles and control 
    # the quality via the DPIs of the output helps in this case
    # in a PDF file, this way only the data layer in the map is rasterized
    # data is masked here with the land-ocean mask
    pdo = ax1.tripcolor(triang, 
        facecolors=np.ma.masked_where(
        ds['FR_LAND'][:].isel(cell=mask).values <= 0.5, 
        ds['topography_c'][:].isel(cell=mask).values), 
        transform=crs_data, shading='flat', edgecolors='none', 
        rasterized=False, 
        cmap=cmapDiscr, vmin=levelsVals[0], vmax=levelsVals[-1])

    # optionally, also a filled contour plot is possible
    # pdo = ax1.tricontourf(tri.Triangulation(clon, clat), 
    #      ds['topography_c'][:].isel(cell=mask).values, 
    #      cmap=cmapDiscr, levels=levelsVals, transform=crs_data)

    # setting map extend w/ rot. coords, as the map projection is in rot. coords
    # no triangle (no matter how coarse the resolution) is cut at the map edge
    plt.xlim(vlon_rot_min, vlon_rot_max)
    plt.ylim(vlat_rot_min, vlat_rot_max)

    cb = plt.colorbar(pdo, ax=ax1, extend='both', pad=0.03, shrink=0.8, 
                      orientation='horizontal', ticks=levelsVals[::10])
    cb.ax.tick_params(labelsize=8)
    cb.set_label('Surface altitude [m]', fontsize=9)

    # There is an interplay of (i) format, (ii) figure size, (iii) rasterized or
    # vectorized data plotting (see "rasterized" keyword), (iv) the graphics 
    # file plotting resolution setting (dpi) 
    # Some recommendations from testing with 3km R13B07 and 12km R13B05 ICON
    # grids over the EUR-12 (formerly EUR-11) domain:
    # "S(mall)": 5-inch plot (eventually a slightly smaller plot is generated)
    # "L(arge)": 10-inch plot
    # w/ 3km with 5inch figsize: 
    # - PNG output: restarized=True/False @3000dpi at does not matter RE 
    #   quality or file size, it is the same, processing speed was not checked,
    #   the PNG files become relatively large, >10MB, easily
    # - PDF output: restarized=True/False @3000dpi matters a lot; RE quality: 
    #   rasterized plots show no hairlines between the triangles, there is no 
    #   viewer issue (slow builtup due to many geomatric objects) when 
    #   displaying the PDF file; there is slightly less edge precision, depdning
    #   on the dpi; the biggest difference is with the file size, even at very 
    #   high plotting resolution (dpi), the rasterized file yield 6MB vs 47MB of
    #   the all vectorized file 
    # - PDF/PNG output with restarized=True and lower plotting resolution of 
    #   1500dpi for further file size reduction is not sufficient in terms of 
    #   quality, triangles are then blurred
    # - conclusion:
    #   w/ PNG: 3000dpi needed, rasterized setting does not matter 
    #   w/ PDF: 3000dpi needed + rasterized=True
    # w/ 12km with 5inch figsize:
    # - execution speed is about 30sec in all cases
    # - PNG output: restarized=True/False @2000dpi does not matter RE plot 
    #   quality or file size, 
    # - PDF output: restarized=True/False @2000dpi matters; RE quality: as with
    #   3km, but the file size does not differ too much, 2MB vs 3MB, 
    # - conclusion:
    #   w/ PNG: 2000dpi is sufficient, rasterized=T/F does not matter 
    #   w/ PDF: 2000dpi is sufficient, rasterized=T is slightly smaller than the
    #   PNG file, the quality is OK, no artifacts
    # in general:
    # --> rasterized=False and PDF always has the highest precision, albeit with 
    #     the hairlines and too large file sizes, irrespective of the dpi
    # --> large figsizes: lower dpi with PNGs and higher dpi w/ PDFs and 
    #     rasterized=T may work well with an OK filesize
    # --> with 12km the rasterized pdf may be improved further with little 
    #     impact on the file size by plotting with 3000dpi 
    # --> PNG output always OK, but has large filesize and other file format
    #     related specific properties; file sizes is about x2 as compared to 
    #     PDFs the quality of highres PNG is not much better than with a  
    #     rasterized PDF
    # ==> if PDF is OK and extreme geometric precision is not an issue use 
    #     rastereized=True + high dpi numbers, like 3000dpi for 3km and 2000dpi 
    #     for 12km
    fig1.savefig('./map_2d_icon_triGrid_extpar-12km-EUR11-orog_allVec_S_2000dpi.pdf', 
                 bbox_inches='tight', pad_inches=0.1, dpi=2000)
    fig1.savefig('./map_2d_icon_triGrid_extpar-12km-EUR11-orog_allVec_S_2000dpi.png', 
                 bbox_inches='tight', pad_inches=0.1, dpi=2000)
    
    print('exec wallclock time =  %0.3f s' % (time.time() - t1))

    plt.show()


if __name__ == '__main__':

    main()
