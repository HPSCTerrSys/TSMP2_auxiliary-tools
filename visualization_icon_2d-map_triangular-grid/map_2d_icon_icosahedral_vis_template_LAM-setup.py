#!/usr/bin/env python
# coding: utf-8

'''
Visualisation template for plotting ICON data on its icosahedral grid on a map

Purpose:
This is a template and demonstrator on how TSMP2 ICON or eCLM data on its native 
simulation grid can be plotted with a rotated map projection as a basis. E.g., 
ICON over a EURO-CORDEX model domain. Can be used as a basis.

Inputs:
- ICON main grid file
- External parameter file
- Rotated pole longitude and latitude
All based on the Zonda ICON Grid and EXTPAR Interface. Using the "europe011" 
template.
'''

import time, sys

import xarray as xr
import numpy as np

import matplotlib.pyplot as plt
import matplotlib.tri as tri
import cartopy.crs as ccrs
import cartopy.feature as cfeature


__authors__ = "Klaus GOERGEN"
__orcid__ = "https://orcid.org/0000-0002-4208-3444"
__email__ = ""
__maintainer__ = "Klaus GOERGEN"
__copyright__ = "Copyright (c) 2025, https://www.fz-juelich.de (FZJ)"
__license__ = "MIT"
__version__ = "1.0.0"
__date__ = "2025-08-11"
__status__ = "Beta"
__credits__ = [
    "DKRZ",
    "Niklas WAGNER"
    ]
__acknowledgements__ = [
    "The authors acknowledge the use of the Zonda service (https://zonda.ethz.ch/) for the preparation of external parameter data for the ICON model. Zonda has been developed and is maintained by the Center for Climate Systems Modeling (C2SM), ETH Zurich, in cooperation with the Federal Office for Meteorology and Climatology MeteoSwiss and Deutscher Wetterdienst (DWD)."
    ]
__references__ = [
    "https://docs.dkrz.de/doc/visualization/sw/python/source_code/python-matplotlib-example-unstructured-icon-triangles-plot-python-3.html",
    "https://docs.dkrz.de/doc/visualization/sw/python/source_code/python-matplotlib-triangular-grid-with-tripcolor-ICON.html",
    "https://zonda.ethz.ch"
    ]


def main():

    t1 = time.time()

    # rotated pole: hardcoded (assume only basic files exist) or from file  
    lon_northpole = -162.0
    lat_northpole = 39.25
    # data generated by ZONDA
    dsPnFn = '../data_test_geo.EUR-12_R13B05_ICON_via-zonda_v20250731orig/europe011_DOM01_external_parameter.nc'
    gridPnFn = '../data_test_geo.EUR-12_R13B05_ICON_via-zonda_v20250731orig/europe011_DOM01.nc'
    #dsPnFn = '../data_test_geo.EUR-3_R13B07_ICON_via-zonda_v20250731orig/europe011_DOM01_external_parameter.nc'
    #gridPnFn = '../data_test_geo.EUR-3_R13B07_ICON_via-zonda_v20250731orig/europe011_DOM01.nc'
    
    ds = xr.open_dataset(dsPnFn)    
    dsGrid = xr.open_dataset(gridPnFn)
    #print(ds)
    #print(dsGrid)

    # triangle (=grid cells) center coords
    clon = np.rad2deg(dsGrid.clon.values)
    clat = np.rad2deg(dsGrid.clat.values)
    # triangle vertex coords
    vlon = np.rad2deg(dsGrid.vlon.values)
    vlat = np.rad2deg(dsGrid.vlat.values)

    # define a rectangular geographic mask
    # default is for full domain by using large limits
    # 40 50 4 9 for western Alps testing
    mask = (
    (clat > 0)
    & (clat < 90)
    & (clon > -180)
    & (clon < 180)
    )

    # corner indices for each triangular grid cell
    # counting needs to be reset from starting at 1 to 0, and transposed
    voc = dsGrid.vertex_of_cell.T[mask].values - 1

    # get the extend of the geolocated data (model domain) 
    used_vertices = np.unique(voc)

    # generate a rotated grid of the vertices coords
    # https://www.dwd.de/SharedDocs/downloads/DE/modelldokumentationen/nwv/cosmo_de/cosmo_de_dbbeschr_version_2_4_161124.pdf
    # np.radians(dsRotClGrid.rotated_pole.grid_north_pole_longitude)
    # np.radians(dsRotClGrid.rotated_pole.grid_north_pole_latitude)
    lon_northpole_rot = np.radians(lon_northpole)
    lat_northpole_rot = np.radians(lat_northpole)
    vlon_rot = np.degrees(np.arctan2(-np.cos(dsGrid.vlat.values)*
        np.sin(dsGrid.vlon.values - lon_northpole_rot), 
        -np.cos(dsGrid.vlat.values)*np.sin(lat_northpole_rot)*
        np.cos(dsGrid.vlon.values-lon_northpole_rot)+
        np.sin(dsGrid.vlat.values)*np.cos(lat_northpole_rot))) 
    vlon_rot[vlon_rot<-180] += 360
    vlon_rot[vlon_rot>180] -= 360
    vlat_rot = np.degrees(np.arcsin(np.sin(dsGrid.vlat.values)*
        np.sin(lat_northpole_rot)+np.cos(dsGrid.vlat.values)*
        np.cos(lat_northpole_rot)*np.cos(dsGrid.vlon.values - 
        lon_northpole_rot)))

    # map extend baed on rotated vertices' coords, no cutting of triangles
    vlat_rot_min = vlat_rot[used_vertices].min()
    vlat_rot_max = vlat_rot[used_vertices].max()
    vlon_rot_min = vlon_rot[used_vertices].min()
    vlon_rot_max = vlon_rot[used_vertices].max()

    # triangulation object from ICON, no Delaunay triangulation
    # very efficient, takes minimum time
    triang = tri.Triangulation(vlon, vlat, voc)
    #print(triang, triang.triangles.shape, triang.is_delaunay)

    # use data + map projection
    # from ICON "main grid file"
    # :grid_mapping_name = "lat_long_on_sphere" ;
    # :crs_id = "urn:ogc:def:cs:EPSG:6.0:6422" ;
    # :crs_name = "Spherical 2D Coordinate System"
    crs_data = ccrs.PlateCarree()
    crs_map = ccrs.RotatedPole(pole_longitude=-162, pole_latitude=39.25)

    # demo with 10inch
    # single column 3.5inch
    # double column 7.0inch
    # slides 5.75inch, e.g., @300dpi with png
    fig1 = plt.figure(figsize=(5.0, 5.0))

    ax1 = plt.subplot(111, projection=crs_map)
    ax1.set_aspect('equal')

    ax1.coastlines(resolution='50m',linewidth=0.5)
    # ax1.gridlines(dms=True, linewidth=1, color='gray', alpha=0.5, 
    #               linestyle='--',
    #               draw_labels={"bottom": "x", "left": "y"}, 
    #               x_inline=False, y_inline=False)
    # ax1.add_feature(cfeature.BORDERS, linestyle='-', alpha=.5, linewidth=0.5)
    ax1.add_feature(cfeature.OCEAN, color='azure')
    # ax1.add_feature(cfeature.LAKES, color='skyblue')

    ax1.set_title('ICON external parameters (EUR-12),\nplotting demo with icosahedral grid', 
        fontsize=9)

    # ax1.text(0.015, 0.88, "stats surf. w. change [mm]:\n"+
    #     "q05 = "+ str(da.quantile(0.05).values.round(1))+"\n"
    #     "q25 = "+ str(da.quantile(0.25).values.round(1))+"\n"
    #     "med = "+ str(da.median().values.round(1))+"\n"
    #     "mean = "+ str(da.mean().values.round(1))+"\n"
    #     "q75 = "+ str(da.quantile(0.75).values.round(1))+"\n"
    #     "q95 = "+ str(da.quantile(0.95).values.round(1))+"\n",
    #     transform=ax.transAxes, ha='left', va='top', fontsize=7)

    cmapDiscr = plt.get_cmap('terrain', 50)
    levelsVals = (np.arange(51)*50)

    # for an all-vectorized option just "rasterized=False", need to test
    # if you have any hairline issue, rasterize the data triangles and control 
    # the quality via the DPIs of the output
    pdo = ax1.tripcolor(triang, 
        facecolors=np.ma.masked_where(
        ds['FR_LAND'][:].isel(cell=mask).values <= 0.5, 
        ds['topography_c'][:].isel(cell=mask).values), 
        transform=crs_data, shading='flat', edgecolors='none', 
        rasterized=False, 
        cmap=cmapDiscr, vmin=levelsVals[0], vmax=levelsVals[-1])

    # optionally, also a filled contour plot is possible
    # pdo = ax1.tricontourf(tri.Triangulation(clon, clat), 
    #      ds['topography_c'][:].isel(cell=mask).values, 
    #      cmap=cmapDiscr, levels=levelsVals, transform=crs_data)

    # setting map extend w/ rot. coords, as projection is in rot. coords
    plt.xlim(vlon_rot_min, vlon_rot_max)
    plt.ylim(vlat_rot_min, vlat_rot_max)

    cb = plt.colorbar(pdo, ax=ax1, extend='both', pad=0.03, shrink=0.8, 
                      orientation='horizontal', ticks=levelsVals[::10])
    cb.ax.tick_params(labelsize=8)
    cb.set_label('Surface altitude [m]', fontsize=9)

    # some recommendations from testing:
    # "S(mall)": 5-inch plot (is eventually smaller)
    # "L(arge)": 10-inch plot
    # w/ 3km @5inch: 
    # - PNG restarized=True/False @3000dpi does not matter RE quality+size, 
    #   processing speed?
    # - PDF restarized=True/False @3000dpi matters RE quality: no hairlines, no 
    #   viewer speedup issue, slightly less edge precision,+size: 6MB vs 47MB, 
    #   processing speed? the hige filesize difference matters here most
    # - PDF/PNG restarized=True @1500dpi: not sufficient in terms of quality
    # --> 5inch normal plot, 3km: 
    #     w/ png: 3000dpi needed, rasterized does not matter 
    #     w/ pdf: 3000dpi needed + rasterized
    # w/ 12km @5inch:
    # - execution speed is about 30sec
    # - PNG restarized=True/False @2000dpi does not matter RE quality+size, 
    #   processing speed is the same
    # - PDF restarized=True/False @2000dpi matters RE quality: no hairlines, no 
    #   viewer speedup issue, slightly less edge precision,+size: 2MB vs 3MB, 
    #   processing speed is the same
    # --> 5inch normal plot, 12km: 
    #     w/ png: 2000dpi OK, rasterized T/F does not matter 
    #     w/ pdf: 2000dpi OK, rasterized T is slightly smaller tahn png, 
    #             quality is OK
    # in general:
    # --> rasterized=False and PDF always has the highest precision, albeit with 
    #     the hairlines and too large file sizes
    # --> large plot sizes: lower dpi png and higher dpi w/ rasterized may work 
    #     well with OK filesize
    # --> with 12km the rastereized pdf without size issues may be improved 
    #     at no cost on file size by going up to 3000dpi 
    # --> png is always OK, but has large filesize and other file format related 
    #     properties; filesizes is about x2 from png and quality is not much 
    #     better
    # ==> if pdf is OK and extreme geometric precision is not an issue use 
    #     rastereized=True + high dpi numbers, like 3000dpi for 3km and 2000dpi 
    #     for 12km 
    fig1.savefig('./map_2d_icon_triGrid_extpar-12km-EUR11-orog_allVec_S_2000dpi.pdf', 
                 bbox_inches='tight', pad_inches=0.1, dpi=2000)
    fig1.savefig('./map_2d_icon_triGrid_extpar-12km-EUR11-orog_allVec_S_2000dpi.png', 
                 bbox_inches='tight', pad_inches=0.1, dpi=2000)
    
    print('exec wallclock time =  %0.3f s' % (time.time() - t1))

    plt.show()


if __name__ == '__main__':

    main()
